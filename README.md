# Assignment-1

1) For this problem, since you have to find all possible pairs of nums that equal the target, I felt that a sort of nested loop approach was optimal for solving this problem. I used a nested for loop to help check all possible outcomes of two numbers that are in the array. Like the problem described, if they equaled the target integer then you print out the indices and then the program finishes. I created a size integer to hold the size of the array to help the for loops know the bounds to work within. As the algorithm goes, I just had an if statement that checked if the elements i and j when added together equaled target. If so, the program returned those elements of the array in the output that was asked for. This approach has a time complexity of O(N^2) which can be efficient for smaller arrays.

2) For this problem, I went with a similar approach as the first problem. Considering the question is asking you to find all the elements in the array that match the target integer. I created two variables "first", and "second" to track the where the beginning position is located and where the end position is in the array that contains the target integer value. Then, similar to the first problem, I had an integer "size" that kept track of the size of the array that was given to help with the for loop that followed. In the for loop, all that is being looked for is if the nums element i is equal to the target, then it becomes the first position if first is still equal to -1 (if it is that means there has been no change) and then the second position is equal to the end position which is located towards the end of the for loop. And then the output is just printed out the way the question asks. This approach has a time complexity of O(N). What makes it this is the fact that you are looping through the array. 

3) To help find the median of the two sorted arrays, for starters two already sorted arrays num1 and nums2 are initialized with m and n being their respected sizes. I have an integer "total" that is equal to the two sizes added together. Variables for the two median values were initialzed as "med1" and "med2" as well as initializing i and j to help with positioning in the for loop that follows. In the for loop, i and j are used to traverse elements in nums1 and nums2. For each iteration of the loop, the smallest element that can be found from nums1 and nums2 is picked and added to the curr variable. At the end of the problem, if the total number of elements is odd, the med2 value will be used as the median for the output. If the total number of elements comes out to be even, then the median is calculated to find the average between the values held in med1 and med2. This approach has a time complexity of O(m + n) considering that the choice of algorithm iterates through half the elements.


4) For this problem, to remove the nth node from a linked list, first I created a struct named ListNode that defines a node in a singly linked list. Each node will contain a value integer that will stores the number, and a next that is a pointer to the node that follows. In main, I manually created a linked list that have the values 12, 24, 36, 49, and 69. With 12 being the head and so on. The first step after that was to create a temp pointer node that will iterate through the list to help find the size of the nodes. This can be seen in the first while loop. With n being 2 (which is the node we want to delete) I created an integer "deletion" that takes the size and minuses n. If deletion is equal to 0, the head node is deleted and then the head node is moved to the following node. In other cases where deletion isn't equal to 0, there is a for loop that helps find the appropriate node that is wanting to be deleted from the linked list. I created a "node" that is equal to the temp->next position in order to help find the right node. Once the node has been found and deleted, the output is printed in the first while loop, and the final while loop is used to for deallocation to help prevent any memory leaks. This approach has a time complexity of O(1) considering that there are little variables used as well as pointers. What also helps is that the linked list is sorted so there is no extra space that is needed. 



5) With a similar start like the previous problem, I created a Struct titled "ListNode" that contains a singly linked list where each node has a "value" that stores the integer, and a "next" that is a pointer that is used for the node that follows. In main, I first created three sorted linked lists titled "one", "two", and "three". I then added them all to one array list titled "list". I have a size value that was initailized to 0 to begin and an integer l that holds the size of the list. The first for loop iterates through all the linked lists to count the total amount of nodes which is where size is being incremented. I then dynamically allocate the array into "arr[size]" which will store all the values from the linked lists. I have a following for loop that traverses each list and helps copy the values into the array "arr". Next I used a method from the algorithm library "sort" that helps sort the array. This has a time complexity of O(N log N). Next, a new linked list is created using the sorted array. a temporary list "newList" is initialized to help with creating the final list. In the while loop, after creating the "merged" linked list, the sorted values are printed out with the "->" arrow following after the other. After all the values are printed, "arr" is deleted at the end to deallocate the allocated memory that helps with preventing any memory leaks. This approach does have a time complexity of O(N) for the most part considering that each of the linked lists are traversed only once, every node is only visted once when they are being copied, and when the linked list is being put back together for the final output. The only time this approach has a different time complexity is when the sort method is used when sorting the array, when this occurs, the time complexity is O(N log N).



